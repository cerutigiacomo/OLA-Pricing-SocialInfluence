
    ‚óè for every primary product, the pair and the order of the secondary products to display
      is fixed by the business unit and cannot be controlled,
    ‚óè the price of every primary product is a variable to optimize,
    ‚óè the expected values of the ùõº ratios are known.

For simplicity, assume that there are:
    four values of price for every product
    the price can be changed once a day.
    For every product, order the prices in increasing levels.
    Every price is associated with a known margin.
On the other hand, for every product,
    the conversion probability associated with each price value is a random variable whose mean is
    unknown.


1   Environment. Develop the simulator by Python. In doing that,
    imagine a motivating application and specify an opportune choice of the
    probability distributions associated with every random variable.
    Moreover, assume that there are 2 binary features that define 3 different user classes.
    The users‚Äô classes potentially differ for
        the demand curves of the 5 products,
        number of daily users,
        ùõº ratios,
        number of products sold,
        and graph probabilities.
    That is, for every random variable, you need to
    provide three different distributions, each one corresponding to a different users‚Äô class.

2   Optimization algorithm. Formally state the optimization problem where the objective
    function is the maximization of the cumulative expected margin over all the products. Design
    a greedy algorithm to optimize the objective function when all the parameters are known.
    The algorithm works as follows. At the beginning, every item is associated with the
    corresponding lowest price. Then, evaluate the marginal increase obtained when the price of
    a single product is increased by a single level, thus considering 5 potential different price
    configurations at every iteration, and choose the price configuration providing the best
    marginal increase (a price configuration specifies the price of every product). The algorithm
    stops when no new configuration among the 5 evaluated is better than the previous one. For
    instance, at the beginning, evaluate the 5 price configurations in which all the products are
    priced with the lowest price except for one product which is priced with the second lowest
    price. If all these price configurations are worse than the configuration in which all the
    products are priced with the lowest price, stop the algorithm and return the configuration with
    the lowest price for all the products. Otherwise, choose the best price configuration and
    re-iterate the algorithm. Notice that the algorithm monotonically increases the prices as well
    as the cumulative expected margin. Therefore, the algorithms cannot cycle. However, there
    is not guarantee that the algorithm will return the optimal price configuration. Develop the
    algorithm by Python.

3   Optimization with uncertain conversion rates. Focus on the situation in which the
    binary features cannot be observed and therefore data are aggregated. Design bandit
    algorithms (based on UCB and TS) to face the case in which the conversion rates are
    unknown. Develop the algorithms by Python and evaluate their performance when applied to
    your simulator.

4   Optimization with uncertain conversion rates, ùõº ratios, and number of items sold per
    product. Do the same of Step 3 when also the alpha ratios and the number of items sold per
    product are uncertain. Develop the algorithms by Python and evaluate their performance
    when applied to your simulator.

5   Optimization with uncertain graph weights. Do the same as Step 3 when the
    uncertain parameters are the graph weights. Develop the algorithms by Python and evaluate
    their performance when applied to your simulator.

6   Non-stationary demand curve. Now assume that the demand curves could be
    subjected to abrupt changes. Use a UCB-like approach with a change detection algorithm to
    face this situation and show whether it works better or worse than using a sliding-window
    UCB-like algorithm. Develop the algorithms by Python and evaluate their performance when
    applied to your simulator.

7   Context generation. Do the same of Step 4 when the features can be observed by
    the ecommerce website. For simplicity, run the context-generation algorithms only every 2
    weeks. When we have multiple contexts, the prices of each single context can be chosen
    and thus optimized independently of the others. Develop the algorithms by Python and
    evaluate their performance when applied to your simulator.

For the Steps 3-7, in the algorithm evaluation, report:
    ‚óè the average regret and reward computed over a significant number of runs,
    ‚óè their standard deviation,
    ‚óè when theoretical bounds are available, also report the ratio between the empiric
      regret and the upper bound
